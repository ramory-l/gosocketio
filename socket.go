package gosocketio

import (
	"sync"
	"sync/atomic"

	"github.com/ramory-l/gosocketio/engineio"
)

// Socket represents a client connection to a Socket.IO namespace.
//
// Each socket has a unique ID and can join/leave rooms, emit events,
// and register event handlers. Sockets are automatically cleaned up
// when the client disconnects.
//
// All methods are goroutine-safe and can be called concurrently.
type Socket struct {
	id         string
	session    *engineio.Session
	namespace  *Namespace
	rooms      map[string]bool
	roomsMu    sync.RWMutex
	handlers   map[string][]EventHandler
	handlersMu sync.RWMutex
	ackID      atomic.Int64
	ackHandlers sync.Map
	data       sync.Map
	onDisconnect []func(string)
	disconnectMu sync.RWMutex
}

// EventHandler is a function that handles Socket.IO events.
//
// The handler receives event data as variadic arguments. If the client
// requested an acknowledgment, the last argument will be a function
// that can be called to send the acknowledgment response.
type EventHandler func(...interface{})

// AckHandler is a function that handles acknowledgment responses.
//
// The handler receives the acknowledgment data from the client as
// variadic arguments.
type AckHandler func(...interface{})

// NewSocket creates a new socket
func NewSocket(id string, session *engineio.Session, namespace *Namespace) *Socket {
	socket := &Socket{
		id:        id,
		session:   session,
		namespace: namespace,
		rooms:     make(map[string]bool),
		handlers:  make(map[string][]EventHandler),
	}

	session.OnMessage(socket.handleMessage)
	session.OnClose(socket.handleClose)

	return socket
}

// ID returns the unique identifier for this socket connection.
//
// The ID is generated by the server and remains constant for the lifetime
// of the connection. It can be used to target specific clients when broadcasting.
func (s *Socket) ID() string {
	return s.id
}

// Emit sends an event to the client.
//
// The event name is sent as a string, followed by any number of data arguments.
// The data can be of any type that is JSON-serializable.
//
// Example:
//
//	socket.Emit("message", "Hello, client!")
//	socket.Emit("user", map[string]interface{}{"name": "John", "age": 30})
func (s *Socket) Emit(event string, data ...interface{}) error {
	args := make([]interface{}, 0, len(data)+1)
	args = append(args, event)
	args = append(args, data...)

	packet := &Packet{
		Type:      PacketTypeEvent,
		Namespace: s.namespace.name,
		Data:      args,
	}

	return s.sendPacket(packet)
}

// EmitWithAck sends an event to the client and expects an acknowledgment response.
//
// The acknowledgment handler will be called when the client responds. If the client
// never responds, the handler will not be called.
//
// Example:
//
//	socket.EmitWithAck("question", func(response ...interface{}) {
//	    log.Printf("Client answered: %v", response)
//	}, "What's your name?")
func (s *Socket) EmitWithAck(event string, ack AckHandler, data ...interface{}) error {
	args := make([]interface{}, 0, len(data)+1)
	args = append(args, event)
	args = append(args, data...)

	id := int(s.ackID.Add(1))

	packet := &Packet{
		Type:      PacketTypeEvent,
		Namespace: s.namespace.name,
		Data:      args,
		ID:        &id,
	}

	s.ackHandlers.Store(id, ack)

	return s.sendPacket(packet)
}

// On registers an event handler for the specified event.
//
// Multiple handlers can be registered for the same event. They will be called
// in the order they were registered. Each handler is called in its own goroutine.
//
// If the client requests an acknowledgment when emitting the event, the last
// argument passed to the handler will be a function that can be called to send
// the acknowledgment response.
//
// Example:
//
//	socket.On("message", func(data ...interface{}) {
//	    if len(data) > 0 {
//	        msg := data[0]
//	        log.Printf("Received: %v", msg)
//
//	        // Check if client requested acknowledgment
//	        if len(data) > 1 {
//	            if ackFn, ok := data[len(data)-1].(func(...interface{})); ok {
//	                ackFn("Message received!")
//	            }
//	        }
//	    }
//	})
func (s *Socket) On(event string, handler EventHandler) {
	s.handlersMu.Lock()
	s.handlers[event] = append(s.handlers[event], handler)
	s.handlersMu.Unlock()
}

// Off removes all event handlers for the specified event.
//
// Example:
//
//	socket.Off("message")
func (s *Socket) Off(event string) {
	s.handlersMu.Lock()
	delete(s.handlers, event)
	s.handlersMu.Unlock()
}

// Join adds the socket to the specified room.
//
// Rooms are arbitrary channels that sockets can join and leave. They provide
// a way to broadcast events to a subset of connected clients. A socket can be
// in multiple rooms at once.
//
// Each socket is automatically joined to a room identified by its socket ID.
//
// Example:
//
//	socket.Join("room1")
//	socket.Join("room2")
func (s *Socket) Join(room string) {
	s.roomsMu.Lock()
	s.rooms[room] = true
	s.roomsMu.Unlock()

	s.namespace.adapter.Add(s.id, room)
}

// Leave removes the socket from the specified room.
//
// If the socket is not in the room, this is a no-op.
//
// Example:
//
//	socket.Leave("room1")
func (s *Socket) Leave(room string) {
	s.roomsMu.Lock()
	delete(s.rooms, room)
	s.roomsMu.Unlock()

	s.namespace.adapter.Remove(s.id, room)
}

// Rooms returns a list of all rooms the socket is currently in.
//
// This includes the socket's own room (identified by its socket ID).
//
// Example:
//
//	rooms := socket.Rooms()
//	for _, room := range rooms {
//	    log.Printf("Socket is in room: %s", room)
//	}
func (s *Socket) Rooms() []string {
	s.roomsMu.RLock()
	defer s.roomsMu.RUnlock()

	rooms := make([]string, 0, len(s.rooms))
	for room := range s.rooms {
		rooms = append(rooms, room)
	}
	return rooms
}

// Set stores arbitrary data on the socket.
//
// This is useful for storing user-specific data such as user ID, session info, etc.
// The data persists for the lifetime of the socket connection.
//
// Example:
//
//	socket.Set("userID", 12345)
//	socket.Set("username", "john_doe")
func (s *Socket) Set(key string, value interface{}) {
	s.data.Store(key, value)
}

// Get retrieves data previously stored on the socket using Set.
//
// Returns the value and true if the key exists, or nil and false if not.
//
// Example:
//
//	if userID, ok := socket.Get("userID"); ok {
//	    log.Printf("User ID: %v", userID)
//	}
func (s *Socket) Get(key string) (interface{}, bool) {
	return s.data.Load(key)
}

// OnDisconnect registers a handler to be called when the socket disconnects.
//
// Multiple handlers can be registered and will be called in the order they were
// registered. Each handler receives a reason string explaining why the disconnect
// occurred (e.g., "client disconnect", "server disconnect", "transport close").
//
// Example:
//
//	socket.OnDisconnect(func(reason string) {
//	    log.Printf("Socket %s disconnected: %s", socket.ID(), reason)
//	})
func (s *Socket) OnDisconnect(handler func(string)) {
	s.disconnectMu.Lock()
	s.onDisconnect = append(s.onDisconnect, handler)
	s.disconnectMu.Unlock()
}

// Disconnect forcefully disconnects the socket from the server.
//
// This will trigger OnDisconnect handlers with reason "server disconnect".
//
// Example:
//
//	socket.Disconnect()
func (s *Socket) Disconnect() {
	s.session.Close("server disconnect")
}

func (s *Socket) sendPacket(packet *Packet) error {
	encoded, err := packet.Encode()
	if err != nil {
		return err
	}

	return s.session.Send(&engineio.Packet{
		Type: engineio.PacketTypeMessage,
		Data: []byte(encoded),
	})
}

func (s *Socket) handleMessage(data []byte) {
	packet, err := DecodePacket(string(data))
	if err != nil {
		return
	}

	switch packet.Type {
	case PacketTypeEvent:
		s.handleEvent(packet)
	case PacketTypeAck:
		s.handleAck(packet)
	case PacketTypeDisconnect:
		s.Disconnect()
	}
}

func (s *Socket) handleEvent(packet *Packet) {
	dataArray, ok := packet.Data.([]interface{})
	if !ok || len(dataArray) == 0 {
		return
	}

	event, ok := dataArray[0].(string)
	if !ok {
		return
	}

	args := dataArray[1:]

	// Handle acknowledgment
	if packet.ID != nil {
		ackFunc := func(ackData ...interface{}) {
			ackPacket := &Packet{
				Type:      PacketTypeAck,
				Namespace: s.namespace.name,
				Data:      ackData,
				ID:        packet.ID,
			}
			s.sendPacket(ackPacket)
		}
		args = append(args, ackFunc)
	}

	s.handlersMu.RLock()
	handlers := s.handlers[event]
	s.handlersMu.RUnlock()

	for _, handler := range handlers {
		go handler(args...)
	}
}

func (s *Socket) handleAck(packet *Packet) {
	if packet.ID == nil {
		return
	}

	val, ok := s.ackHandlers.LoadAndDelete(*packet.ID)
	if !ok {
		return
	}

	handler := val.(AckHandler)

	var args []interface{}
	if dataArray, ok := packet.Data.([]interface{}); ok {
		args = dataArray
	}

	go handler(args...)
}

func (s *Socket) handleClose(reason string) {
	// Leave all rooms
	s.roomsMu.RLock()
	rooms := make([]string, 0, len(s.rooms))
	for room := range s.rooms {
		rooms = append(rooms, room)
	}
	s.roomsMu.RUnlock()

	for _, room := range rooms {
		s.Leave(room)
	}

	// Call disconnect handlers
	s.disconnectMu.RLock()
	handlers := s.onDisconnect
	s.disconnectMu.RUnlock()

	for _, handler := range handlers {
		go handler(reason)
	}

	// Remove from namespace
	s.namespace.removeSocket(s.id)
}
